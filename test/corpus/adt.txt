=========================================
plain adt: empty
=========================================

data A

---

(module (adt (type)))

=========================================
plain adt: one nullary con
=========================================

data A = A

---

(module (adt (type) (equals) (constrs (constr (constr_id (constructor))))))

=========================================
plain adt: one unary con
=========================================

data A = A A

---

(module (adt (type) (equals) (constrs (constr (constr_id (constructor)) (type_name (type))))))

=========================================
plain adt: strict
=========================================

data A = A !A !(A A)

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (constr
    (constr_id (constructor))
    (strict_type (type_name (type)))
    (strict_type (type_parens (type_apply (type_name (type)) (type_name (type)))))))))

=========================================
plain adt: tyvars
=========================================

data A a a a = A a !a [a]

---

(module
 (adt
  (type)
  (tyvar)
  (tyvar)
  (tyvar)
  (equals)
  (constrs
   (constr (constr_id (constructor)) (type_name (tyvar)) (strict_type (type_name (tyvar))) (list_type (type_name (tyvar)))))))

=========================================
plain adt: unpack strict
=========================================

data A = A {-# unpack #-} !A

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (constr (constr_id (constructor)) (pragma) (strict_type (type_name (type)))))))

=========================================
plain adt: record
=========================================

data A a = A { a :: A, a, a :: A, a :: {-# unpack #-} !a, a :: !A }

---

(module
 (adt
  (type)
  (tyvar)
  (equals)
  (constrs
   (constr_record
    (constr_id (constructor))
    (record_fields
     (field (field_id (variable)) (annotation) (type_name (type)))
     (comma)
     (field (field_id (variable)) (comma) (field_id (variable)) (annotation) (type_name (type)))
     (comma)
     (field (field_id (variable)) (annotation) (pragma) (strict_type (type_name (tyvar))))
     (comma)
     (field (field_id (variable)) (annotation) (strict_type (type_name (type)))))))))

=========================================
plain adt: multiple cons
=========================================

data A = A | A A | A !A A

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (constr (constr_id (constructor)))
   (bar)
   (constr (constr_id (constructor)) (type_name (type)))
   (bar)
   (constr (constr_id (constructor)) (strict_type (type_name (type))) (type_name (type))))))

=========================================
plain adt: multiple records
=========================================

data A =
  A { a :: A, a :: !A }
  |
  A { a :: A }

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (constr_record
    (constr_id (constructor))
    (record_fields
     (field (field_id (variable)) (annotation) (type_name (type)))
     (comma)
     (field (field_id (variable)) (annotation) (strict_type (type_name (type))))))
   (bar)
   (constr_record
    (constr_id (constructor))
    (record_fields
     (field (field_id (variable)) (annotation) (type_name (type))))))))

=========================================
plain adt: deriving basic
=========================================

data A = A deriving A

---

(module
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))
  (deriving (type))))

=========================================
plain adt: deriving multi, strategy
=========================================

data A = A deriving (A, A) deriving stock (A)

---

(module
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))
  (deriving (type) (comma) (type))
  (deriving (type))))

=========================================
plain adt: deriving via
=========================================

data A = A deriving (A) via (A A)

---

(module
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))
  (deriving
   (type)
   (via (type_parens (type_apply (type_name (type)) (type_name (type))))))))

=========================================
plain adt: deriving on newline, multiple
=========================================

data A =
  A
  deriving A
  deriving A
data A =
  A
  deriving A
  deriving A

---

(module
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))
  (deriving (type))
  (deriving (type)))
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))
  (deriving (type))
  (deriving (type))))

=========================================
plain adt: context
=========================================

data A a (A a) => A = A
data (A a, A a) => A = A

---

(module
 (adt
  (context
   (constraint
    (class_name (type))
    (type_name (tyvar))
    (type_parens (type_apply (type_name (type)) (type_name (tyvar)))))
    (carrow))
  (type)
  (equals)
  (constrs (constr (constr_id (constructor)))))
 (adt
  (context
   (constraint (class_name (type)) (type_name (tyvar)))
   (comma)
   (constraint (class_name (type)) (type_name (tyvar)))
   (carrow))
  (type)
  (equals)
  (constrs (constr (constr_id (constructor))))))

=========================================
plain adt: prim
=========================================

data A = A !A#

---

(module
 (adt
  (type)
  (equals)
  (constrs (constr (constr_id (constructor)) (strict_type (type_name (type)))))))

=========================================
plain adt: forall
=========================================

data A = forall a . A | ∀ a . A

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (forall (tyvar) (forall_dot))
   (constr (constr_id (constructor)))
   (bar)
   (forall (tyvar) (forall_dot))
   (constr (constr_id (constructor))))))

=========================================
plain adt: con context
=========================================

data A = ∀ a . A a => A

---

(module
 (adt
  (type)
  (equals)
  (constrs
   (forall (tyvar) (forall_dot))
   (context (constraint (class_name (type)) (type_name (tyvar))) (carrow))
   (constr (constr_id (constructor))))))

=========================================
plain adt: tyvar kind
=========================================

data A (a :: * -> 'A)

---

(module
 (adt
  (type)
  (annotated_tyvar
   (tyvar)
   (annotation)
   (fun (star) (type_name (promoted (type)))))))

=========================================
plain adt: signature
=========================================

data A :: (k -> '[ 'A]) -> *

---

(module
 (adt
  (type)
  (annotation)
  (fun
   (type_parens
    (fun
     (type_name (tyvar))
     (promoted (list_type (type_name (promoted (type)))))))
   (star))))

=========================================
plain adt: symbolic
=========================================

data a +++ b = a :+++ b

---

(module
 (adt
  (type_infix (tyvar) (type_operator) (tyvar))
  (equals)
  (constrs (constr_infix (type_name (tyvar)) (consym) (type_name (tyvar))))))
